#	FreeEMS - the open source engine management system
#
#	help.mk
#
#	Copyright 2008-2014 Fred Cooke
#
#	This Makefile is part of the FreeEMS project.
#
#	FreeEMS software is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	FreeEMS software is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with any FreeEMS software.  If not, see http://www.gnu.org/licenses/
#
#	We ask that if you make any changes to this file you email them upstream to
#	us at admin(at)diyefi(dot)org or, even better, fork the code on github.com!
#
#	Thank you for choosing FreeEMS to run your engine!




################################################################################
#                               Help Target Text                               #
################################################################################


help:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                        Dependency And Target Summary                         #$(Q)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   Common targets:                                                            #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#       1) help - This comment block                                           #$(Q)
	@echo $(Q)#       2) all - Executes alldebug, slow, slowgc and size                      #$(Q)
	@echo $(Q)#       3) dirs - Creates all of the directories required to build             #$(Q)
	@echo $(Q)#       5) slow - Three stage compilation with assembly retained               #$(Q)
	@echo $(Q)#       6) slowgc - As above, but with garbage collection during linking       #$(Q)
	@echo $(Q)#       7) alldebug - Generates all debug output files                         #$(Q)
	@echo $(Q)#       8) install - Not yet implemented                                       #$(Q)
	@echo $(Q)#       9) release - Performs a full release build                             #$(Q)
	@echo $(Q)#      10) clean - Removes all files and directories generated by building     #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   Second level targets:                                                      #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#       Stage one:                                                             #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#           1) preprocess - run the C preprocessor over the raw C files        #$(Q)
	@echo $(Q)#           2) compile - compile the preprocessed C into assembly              #$(Q)
	@echo $(Q)#           3) assemble - assemble the assembly files into object files        #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#       Stage two                                                              #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#           1) link - Generate ELFs objects                                    #$(Q)
	@echo $(Q)#           2) gclink - As above, but with garbage collection                  #$(Q)
	@echo $(Q)#           3) s19 - Create s19s from elfs                                     #$(Q)
	@echo $(Q)#           4) gcs19 - Create s19s from gc elfs                                #$(Q)
	@echo $(Q)#           5) sizes - Calculate the approximate s19 sizes                     #$(Q)
	@echo $(Q)#           6) gcsizes - Calculate the approximate gc s19 sizes                #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#       Stage three:                                                           #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#           1) maps - Memory map files                                         #$(Q)
	@echo $(Q)#           2) rees - Readelf dumps                                            #$(Q)
	@echo $(Q)#           3) elfdmps - Classic objdump output for final elfs                 #$(Q)
	@echo $(Q)#           4) objdmps - Classic objdump output for each object file           #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   When doing a full build the following steps are taken:                     #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#    1) Pre-process all of the C files                                         #$(Q)
	@echo $(Q)#    2) Compile all preprocessed C files into assembly files                   #$(Q)
	@echo $(Q)#    3) Assemble all assembly files into object files                          #$(Q)
	@echo $(Q)#    4) Link each decoder without garbage collection                           #$(Q)
	@echo $(Q)#    5) Produce a memory map for each elf                                      #$(Q)
	@echo $(Q)#    6) Produce a readelf dump for each elf                                    #$(Q)
	@echo $(Q)#    7) Dump the contents of each decoders elf                                 #$(Q)
	@echo $(Q)#    8) Dump the contents of all object files                                  #$(Q)
	@echo $(Q)#    9) Link each decoder with garbage collection and reporting turned on      #$(Q)
	@echo $(Q)#   10) Produce an s19 loadable firmware file for each elf                     #$(Q)
	@echo $(Q)#   11) Measure each binary image approximately                                #$(Q)
	@echo $(Q)#   12) Measure each decoder object file                                       #$(Q)
	@echo $(Q)#   13) Measure each other object file and summarise                           #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   The release target:                                                        #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   This target is purely for use by lead developers to produce a file set     #$(Q)
	@echo $(Q)#   that is suitable for release and distribution to users and interested      #$(Q)
	@echo $(Q)#   parties. The steps performed are listed below:                             #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#    1) Checks that the repository is consistent                               #$(Q)
	@echo $(Q)#    2) Performs a full clean                                                  #$(Q)
	@echo $(Q)#    4) Removes the doxygen files                                              #$(Q)
	@echo $(Q)#    5) Builds binaries for each decoder type                                  #$(Q)
	@echo $(Q)#    7) Generates a new doxygen site                                           #$(Q)
	@echo $(Q)#    8) Performs a full clean                                                  #$(Q)
	@echo $(Q)#    9) Commits the release files                                              #$(Q)
	@echo $(Q)#   10) Asks for a tag name and tag message                                    #$(Q)
	@echo $(Q)#   11) Tags the release at the automatic commit point                         #$(Q)
	@echo $(Q)#   12) Generates md5 and sha1 checksums into the distribution directory       #$(Q)
	@echo $(Q)#   13) Zips the binaries into the distribution directory                      #$(Q)
	@echo $(Q)#   14) Zips the doxygen site into the distribution directory                  #$(Q)
	@echo $(Q)#   15) Zips the documentation into the distribution directory                 #$(Q)
	@echo $(Q)#   16) Zips the repository into the distribution directory                    #$(Q)
	@echo $(Q)#   17) Zips the source code into the distribution directory                   #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   At that point the developer in charge of release has only to upload        #$(Q)
	@echo $(Q)#   the files found in the distribution directory to appropriate locations     #$(Q)
	@echo $(Q)#   and publicise the fact that a new release has been performed! This         #$(Q)
	@echo $(Q)#   automation removes most opportunity for mistakes and makes release         #$(Q)
	@echo $(Q)#   quality consistent between each successive release cycle!                  #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   Unlisted targets:                                                          #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   Additionally any of the output files can be used as a target directly.     #$(Q)
	@echo $(Q)#   This is perfect for building only what is required for a specific s19.     #$(Q)
	@echo $(Q)#   It is also perfect for working with a single file as you don't have to     #$(Q)
	@echo $(Q)#   wait for other unrelated things to build first nor do you have to wait     #$(Q)
	@echo $(Q)#   for other files to continue building after yours is successful.            #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   Common goals:                                                              #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   You most likely just want to run \"make s19\" or \"make clean\", do that!      #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   To build with a specific compiled in configuration do this instead:        #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#   CLIFLAGS=\"YOURBUILDNAME\" make clean s19                                    #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)################################################################################$(Q)
