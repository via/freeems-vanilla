#	FreeEMS - the open source engine management system
#
#	Makefile
#
#	Copyright 2008-2014 Fred Cooke
#
#	This Makefile is part of the FreeEMS project.
#
#	FreeEMS software is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	FreeEMS software is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with any FreeEMS software.  If not, see http://www.gnu.org/licenses/
#
#	We ask that if you make any changes to this file you email them upstream to
#	us at admin(at)diyefi(dot)org or, even better, fork the code on github.com!
#
#	Thank you for choosing FreeEMS to run your engine!




################################################################################
#                                                                              #
#                             About This Makefile                              #
#                                                                              #
#   This makefile incorporates many non-standard features. In particular, it   #
#   is inspired by Maven 2 and it's highly disciplined release mechanism. By   #
#   automating the release process as much as possible the chance of human     #
#   error is minimised. As much as possible, reuse is employed to keep bugs    #
#   from being introduced when changes are made. Rather than compiling from    #
#   C source files directly to object files, the build is, by default, done    #
#   in three stages, C to pre-processed C, pre-processed C to assembly, and    #
#   assembly to object files. Linking is also a little different with two      #
#   variants available, with and without garbage collection. Target device     #
#   memory usage statistics are available and generated by default when the    #
#   all target is called. Finally, extensive debug information can be          #
#   generated with a single make call.                                         #
#                                                                              #
################################################################################




# All vars, commands and paths
include make/paths.mk

# Source file listings
include make/sources.mk
# Processed groups from the above
include make/groups.mk

# All command options
include make/options.mk

# Default help target text
include make/help.mk

# Individual targets for each decoder
include make/decoders.mk




################################################################################
#                            Generated Dependencies                            #
################################################################################


# Bring in all of the generated deps. Note, if these fail on the first pass of parsing, Make will generate them and reparse.
-include $(DEPENDENCIES) $(DEPENDENCIESRPM) $(DDEPENDENCIES) $(DDEPENDENCIESRPM)




################################################################################
#                           All Target Dependencies                            #
################################################################################


# Build everything the long way
all: alldebug gcsizes sizes size
# Multi stage compilation
slow: sizes size
# Multi stage compilation with garbage collection
slowgc: gcsizes size
# Clean all except release
clean: cleandep cleanasm cleanobj cleanout cleanppc cleans19 cleandebug
# Generate all debug
alldebug: maps rees elfdmps objdmps
# Load the s19 of your choice
#install: clean slow loader
# Perform a release
release: testgit relbuildfull tagrelease
package: relbuildfull relpack1 relpack2 zipsite
publish: package deploydoxy deploy
publishnodoxy: packagenodoxy deploy
packagenodoxy: relbuildfirmware relpack1 relpack2
relbuildfull: clean cleandoxy gendoxy s19
relbuildfirmware: clean s19
relpack1: md5sums  sha1sums  s19zips 
relpack2: zipdocs zipmain zipsrc


# Force dates and versions to be up to date
$(PPCDIR)/globalConstants.pp.c: .FORCE
.FORCE:


################################################################################
#                           Debug Target Definitions                           #
################################################################################


mapsmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                          Generating memory maps....                          #$(Q)
	@echo $(Q)################################################################################$(Q)

maps: link mapsmsg $(ALLMAPS)

$(BUGDIR)/%.map: $(OUTDIR)/%.elf $(BUGDIR)
	$(NM) $< | sort > $@


reesmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                           Reading all elf files...                           #$(Q)
	@echo $(Q)################################################################################$(Q)

rees: link reesmsg $(ALLREAD)

$(BUGDIR)/%.ree: $(OUTDIR)/%.elf $(BUGDIR)
	$(RE) -a -W $< > $@


elfdmpsmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                           Dumping all elf files...                           #$(Q)
	@echo $(Q)################################################################################$(Q)

elfdmps: link elfdmpsmsg $(ALLDMPS)

$(BUGDIR)/%.dmp: $(OUTDIR)/%.elf $(BUGDIR)
	$(DUMP) -spSd $< > $@


objdmpmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                         Dumping all object files....                         #$(Q)
	@echo $(Q)################################################################################$(Q)

objdmps: assemble objdmpmsg $(DUMPS) $(DUMPSRPM)

$(BUGDIR)/%.dmp: $(OBJDIR)/%.o $(BUGDIR)
	$(DUMP) -spSd $< > $@




################################################################################
#                       Link and Copy Target Definitions                       #
################################################################################


linkmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                      Linking the Objects into an ELF...                      #$(Q)
	@echo $(Q)################################################################################$(Q)

link: assemble linkmsg $(ALLELFS)

# link the object files into an elf executable
$(OUTDIR)/$(LABEL)-%.elf: $(OBJDIR)/$(DECDIR)/%.o $(OBJECTS) $(HANDOBJECTS) $(XGOBJECTS) $(OUTDIR)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#               Linking $@ ...$(Q)
	@echo $(Q)################################################################################$(Q)
	$(GCC) $(GCCOPTS) -Wl,$(LINKOPTS) -o $@ $(OBJECTS) $(HANDOBJECTS) $(XGOBJECTS) $<


gclinkmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                      Linking the Objects into an ELF...                      #$(Q)
	@echo $(Q)################################################################################$(Q)

gclink: assemble linkmsg $(GCDELFS)

# link the object files into an elf executable with gc enabled
$(OUTDIR)/$(LABEL)-%.gc.elf: $(OBJDIR)/$(DECDIR)/%.o $(OBJECTS) $(HANDOBJECTS) $(XGOBJECTS) $(OUTDIR)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#               Linking $@ ...$(Q)
	@echo $(Q)################################################################################$(Q)
	$(GCC) $(GCCOPTS) -Wl,$(LINKOPTSGC) -o $@ $(OBJECTS) $(HANDOBJECTS) $(XGOBJECTS) $<
# The links with garbage collection are to ensure that there are no warnings
# TODO find out how to stop .tramp from being collected (or inserted)!
# This will be the only way once Sean's stuff is done and distributed, I can't wait to cut all this bullshit out!


s19msg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                          Building The S19 Files....                          #$(Q)
	@echo $(Q)################################################################################$(Q)

s19: link s19msg $(ALLS19S)
# the gc dependency is temporary until i figure out if the .tramp removal is an issue or not.

# Generate the loadable s19 firmware files
$(S19DIR)/%.s19: $(OUTDIR)/%.elf $(S19DIR)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#               Building $(@F) ...$(Q)
	@echo $(Q)################################################################################$(Q)
	$(COPY) $(COPYOPTS) $< $(@F)
	mv $(@F) $@


sizesmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                          Measuring The S19 Files...                          #$(Q)
	@echo $(Q)################################################################################$(Q)

sizes: s19 sizesmsg $(ALLSIZES) $(ALLDUMMY)


# Roughly measure the s19 sizes
$(OUTDIR)/%.txt: $(S19DIR)/% $(OUTDIR)
	echo $(shell cat $< | wc -l) $(Q)* 16$(Q) > $@

# Have to do this in two stages to allow $(shell exp) use and portability to windows
$(OUTDIR)/%.dummy: $(OUTDIR)/% $(OUTDIR)
	echo $(Q)Flash image size is$(Q) $(shell cat $< | bc -l) $(Q)bytes for $<$(Q)


gcs19msg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                        Building The GC S19 Files....                         #$(Q)
	@echo $(Q)################################################################################$(Q)

gcs19: gclink gcs19msg  $(GCDS19S)

# Generate the garbage collected s19 files temporarily
$(S19DIR)/%.s19: $(OUTDIR)/%.elf $(S19DIR)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#               Building $(@F) ...$(Q)
	@echo $(Q)################################################################################$(Q)
	$(COPY) $(COPYOPTS) $< $(@F)
	mv $(@F) $@

gcsizesmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                        Measuring The GC S19 Files...                         #$(Q)
	@echo $(Q)################################################################################$(Q)

gcsizes: gcs19 gcsizesmsg $(GCDSIZES) $(GCDDUMMY)

# Roughly measure the gc s19 sizes
$(OUTDIR)/%.txt: $(S19DIR)/% $(OUTDIR)
	@echo $(shell cat $< | wc -l) $(Q)* 16$(Q) > $@

# Have to do this in two stages to allow $(shell exp) use and portability to windows
$(OUTDIR)/%.dummy: $(OUTDIR)/% $(OUTDIR)
	@echo $(Q)Flash image size is$(Q) $(shell cat $< | bc -l) $(Q)bytes for $<$(Q)





################################################################################
#                     Size Measuring Target Definition                         #
################################################################################


size: assemble # TODO this should be run for each s19 target with only the one rpm .o file
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                          Measuring The Decoder Binaries...                   #$(Q)
	@echo $(Q)################################################################################$(Q)
	$(SIZE) $(OBJECTSRPM)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                          Measuring All Other Binaries...                     #$(Q)
	@echo $(Q)################################################################################$(Q)
	$(SIZE) -t $(OBJECTS)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                    Add one decoder to the total above and                    #$(Q)
	@echo $(Q)#                   subtract the size reported for freeEMS.o                   #$(Q)
	@echo $(Q)#                   this will give you the actual image size                   #$(Q)
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)#                  Thank you for building FreeEMS firmware!!!                  #$(Q)
	@echo $(Q)#                                                                              #$(Q)
	@echo $(Q)################################################################################$(Q)




################################################################################
#              Preprocess, Compile and Assemble Target Definitions             #
################################################################################


dependenciesmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                        Generating the dependencies...                        #$(Q)
	@echo $(Q)################################################################################$(Q)

dependencies: dependenciesmsg $(DEPENDENCIES) $(DEPENDENCIESRPM) $(DDEPENDENCIES) $(DDEPENDENCIESRPM)

# Generate dependency files for recompilation on change semantics
$(DEPENDENCIES) $(DEPENDENCIESRPM): $(DEPDIR)/%.d: %.c $(ALLH)
	$(GCC) $(CLIBUILD) $(CLIFLAGSARG) -MM -MF $@ -MT $(PPCDIR)/$*.pp.c $<
# Generate dependency files for the dependency files...
$(DDEPENDENCIES) $(DDEPENDENCIESRPM): $(DEPDIR)/%.dd: %.c $(ALLH)
	$(GCC) $(CLIBUILD) $(CLIFLAGSARG) -MM -MF $@ -MT $(DEPDIR)/$*.d $<


preprocessmsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                        Running the C Pre Processor...                        #$(Q)
	@echo $(Q)################################################################################$(Q)

preprocess: preprocessmsg $(PREPROCESSED) $(PREPROCESSEDRPM)

# Generate preprocessed source files to examine
$(PPCDIR)/%.pp.c: %.c $(ALLH) $(PPCDIR)
	$(GCC) $(GCCOPTS) -D BASE_FILE_NAME=\"$(*F)\" -E $< > $@
$(PPCDIR)/decoders/%.pp.c: decoders/%.c $(ALLH) $(PPCDIR)
	$(GCC) $(GCCOPTS) -D BASE_FILE_NAME=\"$(*F)\" -E $< > $@


compilemsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                         Compiling PPC to Assembly...                         #$(Q)
	@echo $(Q)################################################################################$(Q)

compile: preprocess compilemsg $(ASSEMBLIES) $(ASSEMBLIESRPM)

# Generate assembly files to examine
$(ASMDIR)/%.s: $(PPCDIR)/%.pp.c $(ASMDIR)
	$(GCC) -g $(GCCOPTS) -x cpp-output -S -o $@ $<


assemblemsg:
	@echo $(Q)################################################################################$(Q)
	@echo $(Q)#                          Assembling Object Files...                          #$(Q)
	@echo $(Q)################################################################################$(Q)

assemble: compile assemblemsg $(OBJECTS) $(HANDOBJECTS) $(OBJECTSRPM) $(XGOBJECTS)

# Generate object files to link
$(OBJDIR)/%.o: $(ASMDIR)/%.s $(OBJDIR)
	$(GCC) $(GCCOPTS) -c -o $@ $<

$(OBJDIR)/%.o: $(HANDASMDIR)/%.s $(OBJDIR)
	$(GCC) -g $(GCCOPTS) -c -o $@ $<

$(XGOBJDIR)/%.o: $(XGASMDIR)/%.s $(XGOBJDIR)
	$(XGAS) -o $@ $<




# Release process targets
include make/release.mk

# All directory creating targets
include make/dirs.mk

# All clean up targets
include make/clean.mk

# Things which are not real targets
include make/phony.mk
